我幫你重寫一份協議文件，和你現在的 `main.c` 實作、`dshot.c/h` 配置一致。

---

# 4dshot 協議 v1（最終版，固定 20 Bytes）

## 1. 封包格式（固定長度 20 bytes）

```
# C1 C2 C3 C4 F * CC
```

* **`#`**：起始符 (1 byte)
* **C1..C4**：四個通道，每通道 4 位十進位 ASCII，範圍 `0000–2047`

  * C1 → 馬達1 (PA10)
  * C2 → 馬達2 (PA11)
  * C3 → 馬達3 (PA0)
  * C4 → 馬達4 (PA1)
* **`F`**：旗標 (1 byte)

  * `A` = ARM (允許輸出)
  * `D` = DISARM (立即關閉輸出)
  * `S` = STOP (緊急停轉，比 DISARM 更嚴格)
* **CC**：兩位十六進位 ASCII 表示的 1 byte 校驗碼 (2 bytes)

> **總長度 = 20 bytes，無結尾 CR / LF。**

---

## 2. 值域與限幅

* C1..C4 範圍：`0000–2047`
* MCU 端會做限幅處理：

  * `0 → 0`
  * `1 → 1`
  * `2–48 → 48`
  * `>2047 → 2047`

---

## 3. 校驗算法

* **演算法**：簡單 XOR
* **覆蓋範圍**：C1..C4 (16 bytes) + F (1 byte) → 共 17 bytes
* **步驟**：

  1. `crc = 0`
  2. 對 buf\[1]..buf\[17] 每個 byte 執行 `crc ^= byte`
  3. 得到 0–255 結果，轉成兩位十六進位 ASCII（大寫，不足補零）

---

## 4. 範例

* 內容：C1=0850, C2=0850, C3=0600, C4=0600, F=`A`
* 計算區段：`0850085006000600A` (ASCII)
* XOR 結果：0x41 → `"41"`
* 完整封包：

```
#0850085006000600A41
```

---

## 5. 接收端流程

1. 收到 `#` → 開始計數
2. 收滿 21 bytes → 嘗試解包
4. 重新計算 XOR → 與 `CC` 比對
5. 通過 → 更新四路油門變數 g\_throttle\_m1..m4

---

## 6. 時序與保護

* 推薦送包頻率：50–200 Hz
* 超時保護：若 >100ms 沒收到新包 → 自動 DISARM
* 啟動流程：上電後必須先收到 `A` 封包，才能進入 ARM 狀態並開始輸出

---

## 7. 測資

* `#0850085006000600A41` → ARM，有效值 (850, 850, 600, 600)
* `#0000000000000000D44` → DISARM，全關閉

---

這樣你的協議文件就和目前 MCU 程式碼一致，不會再出現「0xDB vs 0x41」的落差了。要不要我幫你把這份協議整理成 Markdown 或 PDF 版本，方便你放在專案文件夾裡？
